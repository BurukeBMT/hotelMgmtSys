rules_version = '2';

// FIRESTORE RULES
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Helper function to get user role
    function getUserRole() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role;
    }

    // Helper function to check if user is admin
    function isAdmin() {
      return isAuthenticated() &&
             getUserRole() in ['super_admin', 'admin', 'manager'];
    }

    // Helper function to check if user is owner
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Users collection
    match /users/{userId} {
      // Allow owners to read their profile, admins can read all users
      allow read: if isAuthenticated() && (isOwner(userId) || isAdmin());

      // Users can update their own profile (except role), admins can update any
      allow update: if isAuthenticated() && (isOwner(userId) || isAdmin()) &&
                     (!('role' in request.resource.data.diff(resource.data).affectedKeys()) || isSuperAdmin());

      // Allow users to create their own profile document (during sign-up)
      allow create: if isAuthenticated() && request.auth.uid == userId ||
                     // Allow creation during payment processing
                     true;

      // Only super admins can delete users
      allow delete: if isSuperAdmin();
    }

    // Bookings collection
    match /bookings/{bookingId} {
      // Helper function to check if booking belongs to user by userId
      function isBookingOwnerByUserId() {
        return resource.data.userId == request.auth.uid;
      }
      
      // Helper function to check if booking belongs to user via guest
      // Note: This uses get() which can be expensive for queries, but necessary for backward compatibility
      function isBookingOwnerByGuest() {
        // Check if the booking's guest has userId matching the current user
        // This allows reading bookings that were created before userId was added
        // Only check if guest_id exists to avoid errors
        return resource.data.guest_id != null && 
               exists(/databases/$(database)/documents/guests/$(resource.data.guest_id)) &&
               get(/databases/$(database)/documents/guests/$(resource.data.guest_id)).data.userId == request.auth.uid;
      }
      
      // Simplified check: allow reading if booking has userId OR if we can verify via guest
      // For queries, Firestore will evaluate this on each document
      function canReadBooking() {
        // First check: booking has userId matching current user
        return resource.data.userId == request.auth.uid ||
               // Second check: booking's guest has userId matching current user
               // This is for backward compatibility with bookings created before userId was added
               isBookingOwnerByGuest();
      }
      
      // Users can read their own bookings (by userId or via guest), admins can read all
      // Allow reading if:
      // 1. Booking has userId matching current user, OR
      // 2. Booking's guest has userId matching current user (for backward compatibility), OR
      // 3. User is admin
      // Note: For queries, Firestore evaluates this rule on each document
      allow read: if isAuthenticated() &&
                   (canReadBooking() || isAdmin());
      
      // Users can create bookings (even if not authenticated, but we create auth user in payment)
      allow create: if true; // Allow public creation for booking flow
      
      // Users can update their own bookings (by userId), admins can update any
      // Also allow updates that add userId (linking booking to user after payment)
      // And allow payment status updates for payment processing
      allow update: if isAuthenticated() &&
                     (isBookingOwnerByUserId() || 
                      isAdmin() ||
                      // Allow adding userId to link booking to user (first time linking)
                      // User can add their own userId to a booking that doesn't have one yet
                      (request.resource.data.userId == request.auth.uid && 
                       !('userId' in resource.data)) ||
                      // Allow payment status updates (for payment processing flow)
                      // This allows updating paymentStatus, status, paymentIntentId, and userId together
                      (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['paymentStatus', 'updatedAt', 'status', 'paymentIntentId', 'userId'])));
      
      // Only admins can delete bookings
      allow delete: if isAdmin();
    }

    // Rooms collection
    match /rooms/{roomId} {
      // Anyone can read rooms (public access for booking flow)
      allow read: if true;
      // Only admins can create/update/delete rooms
      allow write: if isAdmin();
    }

    // Guests collection
    match /guests/{guestId} {
      // Authenticated users can read guests
      allow read: if isAuthenticated();
      // Users can create guests (even if not authenticated, but we create auth user in payment)
      allow create: if true; // Allow public creation for booking flow
      // Allow updates during payment processing
      allow update: if true;
      allow delete: if isAdmin();
    }

    // Employees collection
    match /employees/{employeeId} {
      // Only HR/admins can access
      allow read, write: if isAdmin();
    }

    // Payments collection
    match /payments/{paymentId} {
      // Users can read their own payments
      allow read: if isAuthenticated() &&
                   (resource.data.userId == request.auth.uid || isAdmin());
      // Allow public creation for payment processing (booking flow)
      allow create: if true;
      // Allow updates during payment processing
      allow update: if true;
      allow delete: if isAdmin();
    }

    // Notifications collection
    match /notifications/{notificationId} {
      // Users can read/update their own notifications
      allow read: if isAuthenticated() &&
                   (resource.data.userId == request.auth.uid || isAdmin());
      allow update: if isAuthenticated() &&
                     resource.data.userId == request.auth.uid;
      // Admins can create notifications
      allow create: if isAdmin();
      allow delete: if isAuthenticated() &&
                     resource.data.userId == request.auth.uid;
    }

    // Pricing collection
    match /pricing/{pricingId} {
      // Anyone authenticated can read
      allow read: if isAuthenticated();
      // Only admins can write
      allow write: if isAdmin();
    }

    // Cabins collection
    match /cabins/{cabinId} {
      // Anyone authenticated can read
      allow read: if isAuthenticated();
      // Only admins can write
      allow write: if isAdmin();
    }

    // Departments collection
    match /departments/{departmentId} {
      // Anyone authenticated can read
      allow read: if isAuthenticated();
      // Only admins can write
      allow write: if isAdmin();
    }

    // Attendance collection
    match /attendance/{attendanceId} {
      // Employees can read their own attendance, admins can read all
      allow read: if isAuthenticated() &&
                   (resource.data.employee_id == request.auth.uid || isAdmin());
      // Only admins/HR can create/update attendance
      allow write: if isAdmin();
    }

    // Payroll collection
    match /payroll/{payrollId} {
      // Employees can read their own payroll, admins can read all
      allow read: if isAuthenticated() &&
                   (resource.data.employee_id == request.auth.uid || isAdmin());
      // Only admins/HR can create/update payroll
      allow write: if isAdmin();
    }

    // Privileges collection
    match /privileges/{privilegeId} {
      // Anyone authenticated can read privileges
      allow read: if isAuthenticated();
      // Only admins can write privileges
      allow write: if isAdmin();
    }

    // User privileges collection
    match /user_privileges/{privilegeId} {
      // Users can read their own privileges, admins can read all
      allow read: if isAuthenticated() &&
                   (resource.data.userId == request.auth.uid || isAdmin());
      // Only admins can write user privileges
      allow write: if isAdmin();
    }
  }
}

// STORAGE RULES - DISABLED (Requires billing for Firebase Storage)
// To enable storage, uncomment and enable billing in Firebase Console
/*
service firebase.storage {
  match /b/{bucket}/o {
    // Storage disabled to avoid billing requirements
    // Uncomment below rules if you enable billing and want file storage

    // Users can upload files to their own folder
    match /users/{userId}/{allPaths=**} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && request.auth.uid == userId;
    }

    // Public read, admin write for hotel assets
    match /hotel/{allPaths=**} {
      allow read: if request.auth != null;
      allow write: if false; // Disable writes for now, or add admin check via Firestore
    }

    // Booking attachments
    match /bookings/{bookingId}/{allPaths=**} {
      allow read: if request.auth != null;
      allow write: if request.auth != null;
    }
  }
}
*/
